Z-функция
(подстрока впереди равна подстроке от начала)
O(|s|)
Поиск периода строки: z[i]=|s|-i <=> период = i
vector<int> calc_z (const char * s){
 vector<int> z;
 int len = strlen(s);
 z.resize (len);
 z[0] = len;
 int l = 0, r = 0;
 int j;
 for (int i = 1; i < len; i++)
  if (i > r){
   for (j = 0; ((j + i) < len) && (s[i + j] == s[j]) ; j++);
   z[i] = j;
   l = i;
   r = i + j - 1;
  }
  else
   if (z[i - l] < r - i + 1)
    z[i] = z[i - l];
   else{
    for (j = 1; (s[r + j] == s[r - i + j]) && ((j + r) < len); j++);
    z[i] = r - i + j;
    l = i;
    r = r + j - 1;
   }
 return z;
}

Префикс-функция
(подстрока слева равна подстроке сначала)
O(|s|)
КМП
vector<int> compute_prefix_function(const string& s) {
 int len = s.length();
 vector<int> p(len); // значения префикс-функции
 // индекс вектора соответствует номеру последнего символа аргумента
 p[0] = 0; // для префикса из нуля и одного символа функция равна нулю
 
 int k = 0;
 for(int i = 1; i < len; i++) {
  while ( (k > 0) && (s[k] != s[i]) ) 
   k = p[k-1]; 
  if (s[k] == s[i])
   k++;
  p[i] = k;
 }
 return p;
}

Быстрое возведение в степень
Аналогично "быстрое сложение"
Количество умножений O(logb)
int bin_pow(int a, int b)
{
 int res = 1;
 while(b)
 {
  if(b % 2 == 1)
    res *=a;
  b /= 2;
  a *= a;
 }
 return res;
}

Merge
O(|a|+|b|)
void My_Merge(vector <WordLink> &a, vector <WordLink> &b)
{
 int i = 0;
 int j = 0;
 vector <WordLink> c;
 while ((i < a.size()) || (j < b.size()))
 {

  if((i < a.size()) && (j < b.size()))
  {
   if(a[i] < b[j])
   {
    c.push_back(a[i++]);
   }
   else if(a[i] > b[j])
   {
    c.push_back(b[j++]);
   }
   else
   {
    c.push_back(b[j++]);
    i++;
   }
  }
  else if(i < a.size())
  {
   c.push_back(a[i++]);
  }
  else if(j < b.size())
  {
   c.push_back(b[j++]);
  }
 }
 a.clear();
 b.clear();
 c.swap(a);
}

Бинпоиск
O(log|a|)
size_t first = 0; /* Номер первого элемента в массиве */
size_t last = n;  /* Номер элемента в массиве, СЛЕДУЮЩЕГО ЗА последним */
/* Если просматриваемый участок непустой, first<last */
size_t mid; 
 
if (n == 0)
{
 /* массив пуст */
} 
else if (a[0] > x)
{
 /* не найдено; если вам надо вставить его со сдвигом - то в позицию 0 */
}
else if (a[n - 1] < x)
{
 /* не найдено; если вам надо вставить его со сдвигом - то в позицию n */
}
 
while (first < last)
{
 mid = first + (last - first) / 2;
 
 if (x <= a[mid])
 {
  last = mid;
 }
 else
 {
  first = mid + 1;
 }
}
 
/* Если условный оператор if(n==0) и т.д. в начале опущен - значит, тут раскомментировать! */
if (/* last<n &&*/ a[last] == x)
{
 /* Искомый элемент найден. last - искомый индекс */
}
else
{
 /* Искомый элемент не найден. Но если вам вдруг надо его вставить со сдвигом, то его место - last. */
}

Троичный поиск
double l, r, EPS; // входные данные
while (r - l > EPS) {
 double m1 = l + (r - l) / 3,
  m2 = r - (r - l) / 3;
 if (f (m1) < f (m2))
  l = m1;
 else
  r = m2;
}

Для целочисленных:
int l = 0, r = N - 1;
int m1, m2;
while(l + 3 < r)
{
 m1 = (2 * l + r) / 3;
 m2 = (l + 2 * r) / 3;
 if(A[m1] < A[m2])
  l = m1;
 else r = m2;
}
int i = l;
for(int c = l + 1; c <= r; c++)
 if(arr[c] > arr[i]) i = c;
