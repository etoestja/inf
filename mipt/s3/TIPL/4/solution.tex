\documentclass[a4paper]{article}
\usepackage[a4paper, left=5mm, right=5mm, top=5mm, bottom=5mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage{tikz} %Рисование автоматов
\usetikzlibrary{automata,positioning,arrows}
\usepackage{amsmath}
\usepackage{enumerate}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{wasysym}
\title{Теория и реализация языков программирования.\\Задание 4: Замкнутость регулярных языков, теорема Майхилла-Нероуда и минимальные автоматы}
\date{задано 2013.09.23}
\author{Сергей~Володин, 272 гр.}
\newcommand{\matrixl}{\left|\left|}
\newcommand{\matrixr}{\right|\right|}
% названия автоматов
\def\A{{\cal A}}
\def\B{{\cal B}}
\def\C{{\cal C}}

% регулярные языки
\def\REG{{\mathsf{REG}}}

\newcommand{\niton}{\not\owns}

\begin{document}
\maketitle
\section*{Упражнение 1}
\section*{Задача 1}
{\em Не очень формально:} Состояниями ДКА будут классы эквивалентности, а переходы будут определны также, как в доказательстве теоремы 1 из третьего задания.\newline Будем искать представителей классов и запоминать их. Для всех найденных классов будем добавлять состояния. Сначала $F\ni C_1=C(\varepsilon)$. Определим $C_1$ как начальное. Рассмотрим $\sigma\in\Sigma$. Если $f(\sigma,\varepsilon)=1$, значит, $\sigma$ лежит в том же классе, что и $\varepsilon$. Определим $\delta(C_1,\sigma)=C_1$. Это соответствует определению в теореме: $\varepsilon\in C_1$, $\varepsilon\sigma\in C_1$. Если же $f(\sigma,\varepsilon)=0$, то они лежат в разных классах. Значит, найден представитель нового класса.
Запомним его, обозначим $C_2=C(\sigma)$. Добавим состояние $C_2$. Определим $\delta(C_1,\sigma)=C_2$. Повторим для остальных $\sigma\in\Sigma$ (более подробно далее). Далее повторим рассуждение для всех добавленных состояний:\newline
Заметим, что вместе с состоянием (т.е. классом) известен и представитель $a_k$ его класса $C_k$ (предположение индукции). Рассмотрим $\sigma\in\Sigma$. Если для всех найденных представителей $a_l\in C_l\hookrightarrow f(a_l,a_k\sigma)=0$, то запомним $a_k \sigma$, добавим новое состояние $C(a_k\sigma)$. В любом случае, определим переход $\delta(C(a_k),\sigma)=C(a_k\sigma)$. Свойство $x_i\ni C_i\Rightarrow \delta(C_i,\sigma)=C(x_i\sigma)$ выполнено по построению.\newline
Всего переходов конечное число (так как состояний конечное число), и на каждом шаге определяются переходы из состояния. Поэтому эта часть алгоритма завершится за конечное время.\newline
Имеем построенный автомат со свойством: $\delta(q_0,w)=C(w)$. Выполним обход графа автомата, найдем пути до всех состояний, попутно <<собирая>> слова $w$, по которым туда можно попасть. Используя $g(w)$, пометим эти состояния принимающими, если $g(w)=1$. Тогда $\delta(q_0,w)\in F\Leftrightarrow g(w)=1\Leftrightarrow w\in L$.
\\[5pt]
%Сначала найден $\varepsilon\in C_1$. Если $\varepsilon\sigma\equiv\sigma\notin C(\varepsilon)\Leftrightarrow f(\sigma,\varepsilon)=0$, найден представитель нового класса. Данную процедуру повторяем для всех найденных классов $\sim n^2$ операций, для них же на каждом шаге определяем $\delta(C_i,\sigma)=C_j$, где $x_i\in C_i$~--- найден, $j\colon x_i\sigma\in C_j$. Так будут найдены все классы, потому что на каждом шаге определяются переходы для какого-то состояния ДКА. Состояний конечное число, а когда автомат будет полным, алгоритм можно считать законченным. Корректность следует из построения: $\delta(C_i,\sigma)=C_j\Leftrightarrow x_i\sigma\in C_j$~--- см. доказательство теоремы Майхилла-Нероуда.\newline
{\em Более формально:} $L\subset\Sigma^*\in\REG,\Sigma^*/\sim_L=\{C_i\}\equiv\{C_1,...,C_n\}$ ($n$ неизвестно, $C_i$ попарно различны). $f\colon \Sigma^*\times\Sigma^*\longrightarrow\{0,1\}$~--- задана, $f(x,y)=1\Leftrightarrow x\sim_Ly$.
Построим ДКА $\A\colon L(\A)=L$.\newline
$Q\overset{\mbox{\tiny def}}{=}\{C_i\}, q_0\overset{\mbox{\tiny def}}{=}C(\varepsilon)$. Докажем, что на $n$-м шаге нижеописанного алгоритма выполняется\newline
$P(n)=[\forall i\in\overline{1,n}\hookrightarrow \mbox{найдены }x_i\in C_i, \forall\sigma\in\Sigma\hookrightarrow\mbox{определены }\delta(C_i,\sigma)=C_j\Leftrightarrow C_i\sigma\in C_j]$.
\begin{enumerate}
\item ($n=1$). $\Sigma^*\ni\varepsilon$ принадлежит какому-то классу. Без ограничения общности $\varepsilon\in C_1$. Рассмотрим все $\sigma_k\in\Sigma$. Если $f(\varepsilon,\sigma_k)=1$, то $x$
%ДОДЕЛАТЬ!
\end{enumerate}
\section*{Задача 2}
\section*{Задача 3}
Пусть $x,y$~--- регулярные выражения. Построим НКА $\A,\B$ по РВ $x,y$.
%Докажем, что это можно сделать за $O(|x|^2),O(|y|^2)$: алгоритм сначала ищет самую старшую операцию за $O(|x|)$, затем вызывается рекурсивно для операндов. Каждый из $|x|$ симвов будет рассмотрен не большее количество раз, чем глубина рекурсии, которая не больше $|x|$. При разборе некоторой операции выполняется $O(t)$ действий, где $t$~--- длина подвыражения с этой операцией. Но $t<|x|$.\newline
Построим ДКА $\A',\B'$ по НКА $\A,\B$. В предыдущем задании было показано, что количество состояний ДКА может экспоненциально зависеть от количества состояний НКА. Но последнее является $O(|x|)$, поэтому уже на этом этапе алгоритм не является эффективным.\newline
Построим по $\A',\B'$ минимальные ДКА $\A'',\B''$. Если $L(\A)=L(\B)$, то в них будет одинаковое количество состояний (оно равно количеству классов эквивалентности, а это свойство языка, а не автомата). Также множества ${Q^{\A}}''$ и ${Q^{\B}}''$ будут изоморфны (в смысле функций перехода), так как переходы также определяются через классы эквивалентности {\em здесь дырка!}. Изоморфизм можно проверить обходом графов автоматов (например, поиск в ширину/глубину).\newline
Если же $L(\A)\neq L(\B)$, то алгоритм обхода графа покажет это.
\section*{Задача 4}
\begin{enumerate}
\item $\Sigma=\{0,1\}$. Докажем, что $L(\A)=L$, $L_1\equiv L=\{w\,\big|\,|w|_1=2t,t\in{\mathbb Z}\}$, ДКА $\A:$
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
	  \node[state, initial, accepting]  (q_0)   {$q_0$};
  	  \node[state] (q_1) [right = of q_0] {$q_1$};
  	  \path[->] 
			(q_0)	edge[bend right=40]		node	{$1$}	(q_1)
			(q_1)	edge[bend right=40]		node	{$1$}	(q_0)
			(q_0)	edge[loop below]		node	{$0$}	(q_0)
			(q_1)	edge[loop below]		node	{$0$}	(q_1);
\end{tikzpicture}
\end{center}
Докажем утверждение $P(n)=\big[\forall w\in\Sigma^*\colon |w|=n\hookrightarrow \big(q_0\overset{w}{\longrightarrow}q_i\Rightarrow i=|w|_1\mod 2\big)\big]$.
\begin{enumerate}
\item Докажем $P(0)$. Поскольку $|w|=0\Rightarrow w=\varepsilon$, $P(0)=\big[q_0\overset{\varepsilon}{\longrightarrow}q_i\Rightarrow i=|\varepsilon|_1\mod 2\big]$. Поскольку $\delta(q_0,\varepsilon)=q_{\underline{0}}$, и $\underline{0}=|\varepsilon|_1$, получаем $P(0)\,\blacksquare$
\item Пусть доказано $P(n)$, докажем $P(n+1)$. $P(n)=\big[\forall w\in\Sigma^*\colon |w|=n\hookrightarrow \big(q_0\overset{w}{\longrightarrow}q_i\Rightarrow i=|w|_1\mod 2\big)\big]$. Фиксируем $w\in\Sigma^*,|w|=n+1,w=w_0\sigma,|w_0|=n,|\sigma|=1$. $\A$~--- полный $\Rightarrow(q_0,w)\equiv(q_0,w_0\sigma)\vdash^*(q_i,\sigma)\vdash(q_j,\varepsilon)$. $|w_0|=n\overset{P(n)}{\Rightarrow}i=|w_0|_1\mod 2$. $i\in\{0,1\}\,,\sigma\in\{0,1\}\Rightarrow$ рассмотрим четыре случая:
\begin{enumerate}[a.]
\item ($i=0,\sigma=0$). $(q_0,w_00)\vdash^*(q_0,0)\vdash(q_0,\varepsilon)\Rightarrow q_0\overset{w}{\longrightarrow}q_0\Rightarrow j=0$. $|w|_1\mod 2=|w_0|_1\mod 2+|0|_1\mod 2=0+0=0\Rightarrow 0=j=|w|_1\mod 2=0$.
\item ($i=0,\sigma=1$). $(q_0,w_01)\vdash^*(q_0,1)\vdash(q_1,\varepsilon)\Rightarrow q_0\overset{w}{\longrightarrow}q_1\Rightarrow j=1$. $|w|_1\mod 2=|w_0|_1\mod 2+|1|_1\mod 2=0+1=1\Rightarrow 1=j=|w|_1\mod 2=1$.
\item ($i=1,\sigma=0$). $(q_0,w_00)\vdash^*(q_1,0)\vdash(q_1,\varepsilon)\Rightarrow q_0\overset{w}{\longrightarrow}q_1\Rightarrow j=1$. $|w|_1\mod 2=|w_0|_1\mod 2+|0|_1\mod 2=1+0=1\Rightarrow 1=j=|w|_1\mod 2=1$.
\item ($i=1,\sigma=1$). $(q_0,w_01)\vdash^*(q_1,1)\vdash(q_0,\varepsilon)\Rightarrow q_0\overset{w}{\longrightarrow}q_0\Rightarrow j=0$. $|w|_1\mod 2=|w_0|_1\mod 2+|1|_1\mod 2=(1+1)\mod 2=0\Rightarrow 0=j=|w|_1\mod 2=0$.
\end{enumerate}
\end{enumerate}
Таким образом, $\forall n\in{\mathbb N}\cup\{0\}\hookrightarrow P(n)\Rightarrow \forall n\in{\mathbb N}\cup\{0\}\hookrightarrow \big[\forall w\in\Sigma^*\colon |w|=n\hookrightarrow \big(q_0\overset{w}{\longrightarrow}q_i\Rightarrow i=|w|_1\mod 2\big)\big]\Rightarrow\newline\forall w\in\Sigma^*\hookrightarrow q_0\overset{w}{\longrightarrow}q_{|w|_1\mod 2}$.
Пусть $w\in L\Leftrightarrow |w|_1\mod 2=0\Leftrightarrow q_0\overset{w}{\longrightarrow}q_0\Leftrightarrow w\in L(\A)\,\blacksquare$
\item $\Sigma=\{0,1\}$. $L_2=\{w\,\big|\,|w|_0=2t+1,t\in{\mathbb Z}\}$. Воспользуемся результатом (4.1) и построим ДКА $\B$:\\
\begin{minipage}{0.8\textwidth}
\begin{tabular}{l l}
\begin{minipage}{0.8\textwidth}
Поменяем в автомате из (4.1) нули и единицы местами. Получим $\A'$. Очевидно, $\A'$ будет распознавать все слова, в которых четное количество нулей. $
A'$~--- полный, и все состояния достижимы из $q_0$.
\end{minipage}&
\begin{minipage}{0.4\textwidth}
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
	  \node[state, initial, accepting]  (q_0)   {$q_0$};
  	  \node[state] (q_1) [right = of q_0] {$q_1$};
  	  \path[->] 
			(q_0)	edge[bend right=40]		node	{$0$}	(q_1)
			(q_1)	edge[bend right=40]		node	{$0$}	(q_0)
			(q_0)	edge[loop below]		node	{$1$}	(q_0)
			(q_1)	edge[loop below]		node	{$1$}	(q_1);
\end{tikzpicture}
\end{center}
\end{minipage}\\
\begin{minipage}{0.8\textwidth}
Поэтому, переопределив $F''=Q''\setminus F$, получим $\A''\equiv\B$, который распознает все слова, в которых нечетное количество нулей.
\end{minipage}&
\begin{minipage}{0.4\textwidth}
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
	  \node[state, initial]  (q_0)   {$q_0$};
  	  \node[state, accepting] (q_1) [right = of q_0] {$q_1$};
  	  \path[->] 
			(q_0)	edge[bend right=40]		node	{$0$}	(q_1)
			(q_1)	edge[bend right=40]		node	{$0$}	(q_0)
			(q_0)	edge[loop below]		node	{$1$}	(q_0)
			(q_1)	edge[loop below]		node	{$1$}	(q_1);
\end{tikzpicture}
\end{center}
\end{minipage}\\
\end{tabular}
\end{minipage}
\item Поскольку $L_3=\{\mbox{слова из 0 и 1, в которых четное число единиц и нечетное число нулей}\}=\newline=\{\mbox{слова из 0 и 1, в которых четное число единиц}\}\cap\{\mbox{слова из 0 и 1, в которых нечетное число нулей}\}\equiv L_1\cap L_2$, построим $\C\colon L(\C)=L_3$ по алгоритму, который докажем далее, в (4.4):
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
	  \node[state, initial]  (q_00)   {$q^0_0$};
  	  \node[state, accepting] (q_01) [above right = of q_00] {$q^0_1$};
   	  \node[state] (q_10) [below right = of q_00] {$q^1_0$};
   	  \node[state] (q_11) [above right = of q_10] {$q^1_1$};
   	   \path[->] 
   	 		(q_00)	edge[bend left]		node	{$0$}	(q_01)
   	 				edge[bend left]  node[swap] {$1$}	(q_10)
   	 		(q_01)  edge[bend left]		node[swap]	{$0$}	(q_00)
   	 		   	 	edge[bend left]  node {$1$}	(q_11)
   	 		(q_10)  edge[bend left]		node[swap]	{$0$}	(q_11)
   	 		   	 	edge[bend left]  node {$1$}	(q_00)
   	 		(q_11)  edge[bend left]		node	{$0$}	(q_10)
   	 		   	 	edge[bend left]  node[swap] {$1$}	(q_01);
\end{tikzpicture}
\end{center}
\item Дано: $\Sigma$~--- алфавит, $\A=(Q^\A,\Sigma,q^\A_0,\delta^\A,F^\A),\,\B=(Q^\B,\Sigma,q^\B_0,\delta^\B,F^\B)$~--- полные ДКА, в которых все состояния достижимы из начальных. $\Sigma^*\supset L^\A=L(\A),\Sigma^*\supset L^\B=L(\B)$. Задача: построить ДКА $\C=(Q^\C,\Sigma,q^\C_0,\delta^\C,F^\C)\colon L(\C)=L^\A\cap L^\B$.
\\[5pt]
Определим $Q^\C=Q^\A\times Q^\B$~--- множество всех пар состояних исходных автоматов.\newline
Для краткости будем обозначать $Q^\C\ni (q^\A_i,q^\B_j)\overset{\mbox{\tiny def}}{\equiv}q^i_j$.\newline
Определим $q^\C_0\overset{\mbox{\tiny def}}{=}q^0_0$, $F^\C=\{q^i_j\big|q^\A_i\in F^\A\wedge q^\B_j\in F^\B\}$\newline
Определим $\delta^\C(q^i_j,\sigma)=\big(\delta^\A(q^\A_i,\sigma),\delta^\B(q^\B_j,\sigma)\big)$\newline
Докажем утверждение\newline
$P(n)=\big[\forall w\in\Sigma^*\colon |w|=n\hookrightarrow q^0_0\overset{w}{\longrightarrow}\big(\delta^\A(q^\A_0,w),\,\delta^\B(q^\B_0,w)\big)\big]$
\begin{enumerate}[a.]
\item ($n=0$) $\Sigma^*\ni w,|w|=0\Rightarrow w=\varepsilon$. Тогда $\delta^\C(q^0_0,\varepsilon)\overset{\mbox{\tiny по опр.}}{=}\big(\delta^\A(q^\A_0,\varepsilon),\delta^\B(q^\B_0,\varepsilon)\big)$, как и требовалось.
\item ($n=1$) $\Sigma^*\ni w,|w|=1\Rightarrow w=\sigma\in\Sigma$. Тогда $\delta^\C(q^0_0,w)=\delta^\C(q^0_0,\sigma)\overset{\mbox{\tiny по опр.}}{=}\big(\delta^\A(q^\A_0,\sigma),\delta^\B(q^\B_0,\sigma)\big)$, как и требовалось.
\item ($n+1$). Пусть $P(n)$. Докажем $P(n+1)$. Фиксируем $\Sigma^*\ni w\colon |w|=n+1$. Тогда $w\equiv w_0\sigma,\,|w_0|=n\,\sigma\in\Sigma$. $\delta^\C(q^0_0,w)=\delta^\C(q^0_0,w_0\sigma)\equiv\delta^\C(\delta^\C(q^0_0,w_0),\sigma)\overset{P(n)}{=}\delta^\C(\big(\delta^\A(q^\A_0,w_0),\,\delta^\B(q^\B_0,w_0)\big),\sigma)\overset{\mbox{\tiny по опр.}}{=}\big(\delta^\A(\delta^\A(q^\A_0,w_0),\sigma),\delta^\B(\delta^\B(q^\B_0,w_0),\sigma)\big)\underset{\delta^\A, \delta^\B}{\overset{\mbox{\tiny св-во }}{=}}\big(\delta^\A(q^\A_0,w),\delta^\B(q^\B_0,w)\big)\Rightarrow P(n+1)$.
\end{enumerate}
Получаем $w\in L^\A\cap L^\B\Leftrightarrow w\in L(\A)\cap L(\B)\Leftrightarrow\begin{cases}
w\in L(\A)\\
w\in L(\B)
\end{cases}\Leftrightarrow \begin{cases}
\delta^\A(q^\A_0,w)\in F^\A\\
\delta^\B(q^\B_0,w)\in F^\B\\
\end{cases}\Leftrightarrow \big(\delta^\A(q^\A_0,w),\delta^\B(q^\B_0,w)\big)\in F^\C\overset{P(|w|)}{\Leftrightarrow} \delta^\C(q^0_0,w)\in F^\C\Leftrightarrow w\in L(\C)\,\blacksquare$
\end{enumerate}
\section*{Задача 5}
\begin{tabular}{l l}
Исходный автомат $\A$: & 
\begin{minipage}{0.4\textwidth}\begin{center}
% копипаста из задания
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
  %\draw[help lines] (0,0) grid (3,2);
  \node[state ,initial] (q_0) 					 {$q_0$};
  \node[state, accepting]		    (q_1) [ right = of q_0 ] {$q_1$};
  \node[state]          (q_2) [ right = of q_1] {$q_2$};
  \node[state, accepting]           (q_3) [ right = of q_2] {$q_3$};

  \path[->] 
		(q_0)	edge		node	{$a$}	(q_1)
				edge [bend left] node {$b$}	(q_3)
		(q_1)
				edge		node	{$b$}	(q_2)
		(q_2)
				edge		node	{$b$}	(q_3)
				edge [bend left] node {$a$}	(q_1);
\end{tikzpicture}
\end{center}\end{minipage}\\
\begin{minipage}{0.4\textwidth}
Пополним автомат $\A$ до $\A'$ и удалим недостижимые из $q_0$ состояния: добавим $q_4\in Q',\,q_4\notin F'$, в него направим недостающие переходы:
\end{minipage} &
\begin{minipage}{0.4\textwidth}
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
  %\draw[help lines] (0,0) grid (3,2);
  \node[state ,initial] (q_0) 					 {$q_0$};
  \node[state, accepting]		    (q_1) [ right = of q_0 ] {$q_1$};
  \node[state]          (q_2) [ right = of q_1] {$q_2$};
  \node[state, accepting]           (q_3) [ right = of q_2] {$q_3$};
  \node[state]           (q_4) [ below = of q_2] {$q_4$};

  \path[->] 
		(q_0)	edge		node	{$a$}	(q_1)
				edge [bend left] node {$b$}	(q_3)
		(q_1)
				edge		node	{$b$}	(q_2)
				edge [bend right]		node	{$a$}	(q_4)
		(q_2)
				edge		node	{$b$}	(q_3)
				edge [bend left] node {$a$}	(q_1)
		(q_3)
				edge [bend left]		node	{$b$}	(q_4)
				edge [bend right]		node	{$a$}	(q_4)
		(q_4)
				edge [loop below]		node	{$a,b$}	(q_4);
\end{tikzpicture}
\end{center}
\end{minipage}\\
\end{tabular}\newline
$L(\A')=L(\A)$, так как $x\in L(\A)\Rightarrow x\in L(\A')$, потому что $Q\subset Q',\,F=F',\delta\subset\delta'$. $x\notin L(\A)\Rightarrow$ либо $q_0\overset{x}{\longrightarrow}q\notin F$, но тогда $q_0\overset{x}{\longrightarrow}q\notin F'\Rightarrow x\notin L(\A')$, либо $\delta(q_0,x)=\varnothing$, тогда $\delta'(q_0,x)=q_4$, потому что был выполнен переход в $q_4$, которого не было в $\A$ (по построению, добавлены переходы только в $q_4$), и при обработке последующих символов $\A'$ остается в $q_4$.
\\[5pt]
\begin{tabular}{l l}
\begin{minipage}{0.4\textwidth}
Построим $A''\colon L(\A'')=\overline{L(\A')}\equiv\overline{L(\A)}$ по полному автомату $\A'$, определив $F''\overset{\mbox{\tiny def}}{=}Q'\setminus F'$:
\end{minipage} &
\begin{minipage}{0.4\textwidth}
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
  %\draw[help lines] (0,0) grid (3,2);
  \node[state, initial, accepting] (q_0) 					 {$q_0$};
  \node[state]		    (q_1) [ right = of q_0 ] {$q_1$};
  \node[state, accepting]          (q_2) [ right = of q_1] {$q_2$};
  \node[state]           (q_3) [ right = of q_2] {$q_3$};
  \node[state, accepting]           (q_4) [ below = of q_2] {$q_4$};

  \path[->] 
		(q_0)	edge		node	{$a$}	(q_1)
				edge [bend left] node {$b$}	(q_3)
		(q_1)
				edge		node	{$b$}	(q_2)
				edge [bend right]		node	{$a$}	(q_4)
		(q_2)
				edge		node	{$b$}	(q_3)
				edge [bend left] node {$a$}	(q_1)
		(q_3)
				edge [bend left]		node	{$b$}	(q_4)
				edge [bend right]		node	{$a$}	(q_4)
		(q_4)
				edge [loop below]		node	{$a,b$}	(q_4);
\end{tikzpicture}
\end{center}
\end{minipage}\\
\end{tabular}
\newline
Далее построим по $\A''$ минимальный $\A'''$ по алгоритму:
\newline
\begin{tabular}{c c}
\begin{minipage}{0.4\textwidth}
\begin{enumerate}[1.]
\item \begin{tikzpicture}[baseline=-0.5ex,node distance=10mm,on grid,auto]
\node (d_b) {$\big\{$};
\node (q_0) [node distance=3mm, right of=d_b] {$0$};
\node (q_2) [right of=q_0] {$2$};
\node (q_4) [right of=q_2] {$4$};
\node (d_41) [node distance=5mm, right of=q_4] {$\big|$};
\node (q_1) [right of=q_4] {$1$};
\node (q_3) [right of=q_1] {$3$};
\node (d_f) [node distance=3mm,right of=q_3] {$\big\}$};
\draw[->, bend left] (q_0) to node {$a$} (q_1);
\draw[->, bend left] (q_2) to node {$a$} (q_1);
\draw[->, loop below] (q_4) to node {$a$} (q_4);
\draw[->, bend left] (q_1) to node {$a$} (q_4);
\draw[->, bend right=50] (q_3) to node {$a$} (q_4);
\end{tikzpicture}
\item \begin{tikzpicture}[baseline=-0.5ex,node distance=10mm,on grid,auto]
\node (d_b) {$\big\{$};
\node (q_0) [node distance=3mm, right of=d_b] {$0$};
\node (q_2) [right of=q_0] {$2$};
\node (d_02) [node distance=5mm, right of=q_2] {$\big|$};
\node (q_4) [right of=q_2] {$4$};
\node (d_41) [node distance=5mm, right of=q_4] {$\big|$};
\node (q_1) [right of=q_4] {$1$};
\node (d_13) [node distance=5mm, right of=q_1] {$\big|$};
\node (q_3) [right of=q_1] {$3$};
\node (d_f) [node distance=3mm,right of=q_3] {$\big\}$};
\draw[->, bend right] (q_0) to node {$b$} (q_3);
\draw[->, bend right] (q_2) to node [swap] {$b$} (q_3);
\draw[->, loop below] (q_4) to node {$b$} (q_4);
\draw[->, bend right] (q_1) to node [swap] {$b$} (q_2);
\draw[->, bend right=50] (q_3) to node [swap] {$b$} (q_4);
\end{tikzpicture}~--- OK
\item \begin{tikzpicture}[baseline=-0.5ex,node distance=10mm,on grid,auto]
\node (d_b) {$\big\{$};
\node (q_0) [node distance=3mm, right of=d_b] {$0$};
\node (q_2) [right of=q_0] {$2$};
\node (d_02) [node distance=5mm, right of=q_2] {$\big|$};
\node (q_4) [right of=q_2] {$4$};
\node (d_41) [node distance=5mm, right of=q_4] {$\big|$};
\node (q_1) [right of=q_4] {$1$};
\node (d_13) [node distance=5mm, right of=q_1] {$\big|$};
\node (q_3) [right of=q_1] {$3$};
\node (d_f) [node distance=3mm,right of=q_3] {$\big\}$};
\draw[->, bend left] (q_0) to node {$a$} (q_1);
\draw[->, bend left] (q_2) to node {$a$} (q_1);
\draw[->, loop below] (q_4) to node {$a$} (q_4);
\draw[->, bend left] (q_1) to node {$a$} (q_4);
\draw[->, bend right=50] (q_3) to node {$a$} (q_4);
\end{tikzpicture}~--- OK
\end{enumerate}
\end{minipage} &
\begin{minipage}{0.3\textwidth}
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
  %\draw[help lines] (0,0) grid (3,2);
  \node[state, initial, accepting] (q_0) 					 {$q_0$};
  \node[state]		    (q_1) [ right = of q_0 ] {$q_1$};
  \node[state, accepting] (q_4) [ right = of q_1] {$q_4$};
  \node[state]           (q_3) [ right = of q_4] {$q_3$};

  \path[->] 
		(q_0)	edge [bend right]		node	{$a$}	(q_1)
				edge [bend left] node {$b$}	(q_3)
		(q_1)
				edge [bend right]		node	{$b$}	(q_0)
				edge 		node	{$a$}	(q_4)
		(q_3)
				edge [bend left]		node	{$b$}	(q_4)
				edge [bend right]		node	{$a$}	(q_4)
		(q_4)
				edge [loop below]		node	{$a,b$}	(q_4);
\end{tikzpicture}
\end{center}
\end{minipage}\\
\end{tabular}
\section*{Задача 6}
\end{document}
