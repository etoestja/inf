\documentclass[a4paper]{article}
\usepackage[a4paper, left=5mm, right=5mm, top=5mm, bottom=5mm]{geometry}
%\geometry{paperwidth=210mm, paperheight=2000pt, left=5pt, top=5pt}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage{tikz} %Рисование автоматов
\usetikzlibrary{automata,positioning,arrows,trees,calc}
\usepackage{amsmath}
\usepackage[makeroom]{cancel} % зачеркивание
\usepackage{multicol,multirow} %Несколько колонок
\usepackage{hyperref}
\usepackage{tabularx}
\usepackage{amsfonts}
\usepackage{amssymb}
\DeclareMathOperator*{\argmin}{arg\,min}
\usepackage{listings}
\usepackage{wasysym}
\date{задано 2014.04.10}
\author{Сергей~Володин, 272 гр.}
\newcommand{\matrixl}{\left|\left|}
\newcommand{\matrixr}{\right|\right|}
% названия автоматов  (rubtsov)
\def\A{{\cal A}}
\def\B{{\cal B}}
\def\C{{\cal C}}

%классы сложности (rubtsov)
\def\PP{{\mathsf{P}}}
\def\NP{{\mathsf{NP}}}
\def\NPc{{\mathsf{NP}}\text{-}{\rm c}}
\def\coNP{{\rm co}\text{-}{\mathsf{NP}}}
\def\DTIME{{\mathsf{DTIME}}}
\def\NTIME{{\mathsf{NTIME}}}
\def\CLIQUE{{\mathsf{CLIQUE}}}
\def\HALT{{\rm{HALT}}}
\def\SAT{{\rm{SAT}}}
\def\3SAT{{\rm{3\text{-}SAT}}}
\def\2SAT{{\rm{2\text{-}SAT}}}
\def\UNSAT{{\rm{UNSAT}}}
\def\HP{{\rm{HAMPATH}}}
\def\UHP{{\rm{UHAMPATH}}}
\def\LL{{\mathrm{LL}}}
\def\poly{{\rm{poly}}}
\def\GC{{\mbox{ГЦ}}}
\def\GP{{\mbox{ГП}}}
\def\conv{{\mbox{conv}}}

\title{Алгоритмы и модели вычислений.\\Задание 9: сортировки}

% алгоритмы (Рубцов)
\usepackage{verbatim}
\usepackage{listings}
\usepackage{algorithm2e}

%+= и -=, иначе разъезжаются...
\newcommand{\peq}{\mathrel{+}=}
\newcommand{\meq}{\mathrel{-}=}
\newcommand{\deq}{\mathrel{:}=}
\newcommand{\plpl}{\mathrel{+}+}

\newcommand{\todo}{{\em todo}}

% пустое слово  (rubtsov)
\def\eps{\varepsilon}

% регулярные языки  (rubtsov)
\def\REG{{\mathsf{REG}}}
\def\CFL{{\mathsf{CFL}}}
\def\eqdef{\overset{\mbox{\tiny def}}{=}}
\newcommand{\niton}{\not\owns}

%FIRST & FOLLOW (rubtsov)
\def\first{\mathrm{ FIRST} }
\def\follow{\mathrm{ FOLLOW} }

% LL LR (rubtsov)
\def\LL{{\mathrm{LL}}}
\def\LR{{\mathrm{LR}}}

\newcounter{rowItemCount}
\newcounter{subRowItemCount}
\newcommand\rowItem{
    \setcounter{subRowItemCount}{0}
    \arabic{rowItemCount}.\addtocounter{rowItemCount}{1}}
\newcommand\subRowItem{
    \addtocounter{subRowItemCount}{1}
    \addtocounter{rowItemCount}{-1}
    \arabic{rowItemCount}.\arabic{subRowItemCount}.\addtocounter{rowItemCount}{1}}
    
\newcommand{\smalll}[1]{\overline{\overline{#1}}}
\newcommand{\smallo}{\bar{\bar{o}}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\Nz}{\mathbb{N}\cup\{0\}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\RR}{\mathbb{R}}
\begin{document}
\maketitle
\subsection*{(каноническое) Задача 38}
\subsection*{(каноническое) Задача 39}
\subsection*{(каноническое) Задача 40}
(Модифицируем алгоритм merge sort. Задачу давал Пименов.)
  
  n$-$размер массива.
  
  Количество инверсий в массиве при $n \leqslant
  1$ равно 0.
  
  Пусть посчитаны инверсии для двух
  половинок, а также половинки
  отсортированы.
  
  $c \overset{\mbox{def}}{=} \frac{n}{2}, A = \left[ 1, c \right], B = \left[
  c + 1, n \right] -$множества индексов половинок.
  Тогда посчитаны инверсии для таких пар
  индексор $i \neq j :$
  \begin{itemize}
    \item $i, j \in A -$элементы до середины
    
    \item $i, j \in B -$элементы после середины
  \end{itemize}
  Тогда осталось посчитать инверсии для
  пар, индексы которых принадлежат разным
  множествам. Очевидно, что сортировка
  половинок не изменила количество
  инверсий для таких пар, т.к. порядок
  элементов такой пары в массиве не
  изменился после сортировки.
  
  Будем производить слияние двух
  упорядоченных половинок $l = \left( l_1, \ldots, l_c
  \right)$ и $r = \left( r_1, \ldots, r_{n - c} \right)$, при каждом
  выборе элемента (на каждой итерации
  цикла) будем считать инверсии текущего
  элемента с последующими из другого
  множества (так, заметим, обойдем все
  необходимые пары). Полученные результаты
  будем суммировать (это возможно, т.к.
  каждая пара рассматривается один раз).
  
  Пусть получены $k - 1$ элементов итогового
  массива, выбраны i элементов из первой
  половинки, j из правой. Инверсии для $k - 1$
  также посчитаны.
  
  k-й равен $l_{i + 1}$, если $l_{i + 1} < r_{j + 1}$ или $r_{j +
  1}$ иначе.
  
  Найдем число инверсий для каждого случая:
  \begin{itemize}
    \item Если добавляем $l_{i + 1}$, то
    последующими элементами из другого
    множества (из другой половинки) могут
    быть $r_{j + 1} < r_{j + 2} < \ldots$. Но (условие
    случая) $l_{i + 1} < r_{j + 1} < \ldots \Rightarrow$инверсий
    с последующими нет (т.к. ``более левый'' в
    исходном массиве элемент меньше правых
    из другого множества).
    
    \item Если добавляем $r_{j + 1}$, то
    последующими элементами из другого
    множества будут $l_{i + 1} < l_{i + 2} < \ldots$. Но
    (условие случая) $r_{j + 1} < l_{i + 1} < \ldots$.
    Получаем, что число инверсий равно
    количеству оставшихся элементов из
    левой половинки, т.е. $c - i$ (т.к. ``более
    правый'' в исходном массиве элемент
    меньше такого количества ``более левых''
    из другого множества).
  \end{itemize}
  Очевидно, что время работы такого
  алгоритма равно времени работы merge sort, т.е.
  $T \in O \left( n \log n \right)$
\end{document}