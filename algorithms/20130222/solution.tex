\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{enumerate}
\usepackage{amsfonts}
\title{Задание от 2013.02.22}
\author{С.~Е.~Володин, 272 гр.}
\date{}
\begin{document}
\maketitle
\begin{enumerate} 
\item Задача 1
\begin{enumerate}
\item В обходе в ширину бора $Trie$ на вершине $v$ с предком $p$ и символом $x$ на ребре между ними после вычисления $\pi$-функции как $$\pi(v)=\left\{ \begin{array}{lcr} \pi^k(p)[x], k=min && if\ defined\\ root && else \end{array} \right.$$
проверяем, заканчивается ли в $\pi(v)$ какой-нибудь образец $P_i$. В зависимости от результата,
$$out(v)=\left\{ \begin{array}{lcr} \pi(v) && if\ \exists i: P_i=str(\pi(v))\\ out(\pi(v)) && else \end{array} \right.,$$
где $str(v)$~--- строка от корня до вершины $v$.\newline
Выражение для $out$ определено, так как $\pi(v)$ указывает на вершину с меньшим расстоянием до корня, а выполняется обход в ширину, то есть, вершина $\pi(v)$ уже была посещена.
Докажем корректность. По определению, $out(v)$~--- вершина с образцом, имеющая минимальный номер в последовательности $\pi(v),\pi^2(v),\dots$.\newline
Пусть этот номер равен $1$. Тогда эта вершина $out(v)\equiv\pi(v)$ будет найдена в первом случае.\newline
Пусть номер больше $1$. Тогда эта содержащая образец вершина имеет минимальный номер в $\pi^2(v),\pi^3(v)\dots$, т.е. равна $out(\pi(v))$.\newline
В случае, если связи выхода не существует, $out(v)$ будет указывать на корень.
\item Пусть $i$-й символ строки $s$. Пусть $v$~--- текущее положение в боре. Разбирается часть строки $str(v)$. Тогда все образцы, являющиеся суффиксами $str(v)$ можно найти в последовательности соответствующих им вершин $out(v),out^2(v),\dots$.\newline
Очевидно, что для одного символа дважды найденных образцов не будет, так как в последовательности $v,out(v),out^2(v),\dots$ нет совпадающих элементов ({\em если не считать корень}).\newline
Также дважды найденных образцов не будет и на различных положениях в строке, так как это положение строго монотонно возрастает. А, следовательно, возрастает и крайнее правое положение строки образца.\newline
Каждый образец будет найден, так как в противном случае существовал бы образец, по длине меньший $|str(v)|$~--- так как он в последовательности $out$, но не являющися ее суффиксом.
На разбор строки необходимо $O(m)$. На каждое вхождение будет потрачено константное время (переход по $out$) $\Rightarrow$\newline
Время: $O(m+k)$.
\item Пусть $x$~--- такая позиция в строке $s$, что на ней заканчивается первый образец. $y$~--- позиция, на которой начинается образец. Пусть $x$~--- текущий в обработке строки. Очевидно, что до текущей итерации ни одного образца не было найдено (т.к. тогда бы в $x$ заканчивался не первый образец).\newline
Докажем, что на текущем шаге первый образец будет найден: образец заканчивается на символе $x$, а, следовательно, является суффиксом префикса строки $s$ длины $x$.\newline
Докажем, что корень бора соответствует символу $z$ в строке $s$, который меньше, либо равен $y$. Пусть иначе. Тогда при рассмотрении символа $z$ был совершен переход в корень, хотя в строке содержался префикс образца (и, следовательно, переход должен был произойти к следующему символу префикса образца)~--- противоречие.\newline
Но тогда образца $(s[y],\dots,s[x])$ можно достигнуть по связям $out$ при рассмотрении символа $x$, то есть, образец будет найден.\newline
Поэтому для нахождения первого вхождения какого-либо образца необходимо выполнить обычный алгоритм поиска всех образцов (с использованием $out$-функции). Тогда искомым образцом будет первый найденный.
\end{enumerate}
\item Задача 2.
\begin{enumerate}
\item Построим $\pi$- и $out$-функции. Для этого воспользуемся обходом в ширину. При обработке текущей вершины в очередь добавляются все братья первого ребенка. При добавлении известен их родитель (текущая вершина), поэтому возможно построить функции по формуле из задачи 1 ($p$~--- текущая вершина, $v$~--- текущий добавляемый ребенок, $x$~--- его символ). Время для проверки условия из первой строки для $\pi$ увеличится в $O(|\Sigma|)$ раз (так как размер алфавита~--- максимальное количество детей у вершины)\newline
При движении по строке аналогично время на каждый символ увеличится в $O(|\Sigma|)$ раз.
\item Способ с массивом из указателей хуже по памяти в общем случае (лишние места для незанятых указателей), но быстрее по времени (время $O(1)$, либо $O(|\Sigma|)$ для ответа на вопрос, есть ли у вершины ребенок с определенным символом).
\end{enumerate}
\end{enumerate}

\end{document}
