\documentclass[a4paper]{article}
\usepackage[a4paper, left=5mm, right=5mm, top=5mm, bottom=5mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage{tikz} %Рисование автоматов
\usetikzlibrary{automata,positioning,arrows}
\usepackage{amsmath}
\usepackage{enumerate}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{wasysym}
\title{Теория и реализация языков программирования.\\Задание 4: Замкнутость регулярных языков, теорема Майхилла-Нероуда и минимальные автоматы}
\date{задано 2013.09.23}
\author{Сергей~Володин, 272 гр.}
\newcommand{\matrixl}{\left|\left|}
\newcommand{\matrixr}{\right|\right|}
% названия автоматов
\def\A{{\cal A}}
\def\B{{\cal B}}
\def\C{{\cal C}}

% регулярные языки
\def\REG{{\mathsf{REG}}}

\newcommand{\niton}{\not\owns}

\begin{document}
\maketitle
\section*{Упражнение 1}
\begin{enumerate}[1.]
\item Алгоритм конечен. Действительно, $Q$ можно разделить не больше, чем на $|Q|$ подмножеств, на каждом шаге происходит некоторое разделение.\newline
Действительно, на каждом шаге на каждом символе количество подмножеств не уменьшается, так как $Q_{k,l}$ различно при разных $k$ (значит, элементы из разных <<старых>> подмножеств попадут в разные <<новые>> подмножества).\newline
А если количество подмножеств не увеличилось после $|\Sigma|$ разбиений, алгоритм завершается (по построению).
\item Докажем, что все состояния из одного подмножества эквивалентны. Предположим противное. Тогда $$\exists q_1,q_2\in Q_i \colon q_1\not\sim_L q_2\Rightarrow \forall x_1,x_2\colon q_0\overset{x_1}{\longrightarrow}q_1, q_0\overset{x_2}{\longrightarrow}q_2\hookrightarrow x_1\not\sim_L x_2\Rightarrow \exists w\in\Sigma^*\colon x_1w\in L, x_2w\notin L.$$ Фиксируем $x_1,x_2,w$. Тогда $\delta(q_1,w)\in F, \delta(q_2,w)\notin F$. Пусть $|w|=n$.\newline
Если $|w|=n=0$, то получаем, что $q_1$~--- принимающее, а $q_2$~--- нет. Это противоречие, так как $q_1,q_2\in Q_i$, на первом шаге принимающие и не принимающие были разделены, и (как было доказано выше), состояния, лежащие в различных подмножествах в процессе выполнения алгоритма не могут оказаться в одном.\newline
Пусть $|w|=n>0$. $w=w_1...w_n$. Тогда $(q_1,w)\vdash(q^1_1,w_2...w_n)\vdash...\vdash(q^n_1,\varepsilon),q^n_1\in F$. Аналогично $(q_2,w)\vdash(q^1_2,w_2...w_n)\vdash...\vdash(q^n_2,\varepsilon),q^n_2\notin F$. Поскольку $q_1,q_2\in Q_i$, $\delta(q_1,w_1)$ и $\delta(q_2,w_1)\in Q_j$ по условию окончания алгоритма. Значит, $q^1_1$ и $q^1_2$ лежат в одном подмножестве. Повторяя рассуждение, получаем, что $q^n_1$ и $q^n_2$ лежат в одном подмножестве, что невозможно (доказано выше), так как $q^n_1\in F,q^n_2\notin F$.
\item[2.1.] Получаем, что были склеены только эквивалентные состояния. Значит, язык, распознаваемый автоматом, не изменился.
\item Докажем, что если некоторые два состояния $q_1,q_2$ исходного автомата были эквивалентны, они будут в одном подмножестве $Q_i$. Пусть иначе: они были разделены на некотором шаге.\newline
Это не мог быть второй шаг, так как принимающее и не принимающее состояние не эквивалентны. Докажем это: пусть $F\ni q_1\sim_L q_2\notin F\Rightarrow \exists x_1\sim_L x_2\colon \delta(q_0,x_1)=q_1\in F,\delta(q_0,x_2)=q_2\notin F\Rightarrow x_1\in L,x_2\notin L$. $x_1\sim_L x_2\Rightarrow \forall w\in\Sigma^*\hookrightarrow x_1w\in L\Leftrightarrow x_2w\in L$. Выберем $w=\varepsilon$. Тогда $x_1\in L \Leftrightarrow x_2\in L$~--- противоречие.\newline
Значит, они были разделены на некотором последующем шаге. Найдем первый такой шаг, на котором некоторые эквивалентные состояния $q_1,q_2$ были разделены. Пусть при этом  рассматривался символ $\sigma$: $q_1\overset{\sigma}{\longrightarrow}q_a\in Q_a,q_2\overset{\sigma}{\longrightarrow}q_b\in Q_b,Q_a\neq Q_b$. Поскольку до этого
% <<все было хорошо>>%
эквивалентные состояния оставались в одном подмножестве, получаем, что $q_a$ и $q_b$ не эквивалентны (если это не так, то этот шаг не первый из таких, на котором эквивалентные состояния были разделены~--- противоречие). Значит (доказано ранее), $\exists w\colon \delta(q_a,w)\in F,\delta(q_b,w)\notin F$. Тогда $\delta(q_1,\sigma w)\in F,\delta(q_2,\sigma w)\notin F\Rightarrow$ (доказано ранее) состояния $q_1,q_2$ не эквивалентны~--- противоречие.
\item[3.1.] Получаем, что эквивалентные состояния, и только они, будут склеены. Также количество состояний ДКА не может быть меньше, чем количество классов эквивалентности по $\sim_L$ (доказано в условии). Больше оно тоже быть не может, так как тогда бы в автомате были два эквивалентных состояния, что невозможно (они все были склеены). Значит, количество состояний построенного ДКА будет равно количеству классов эквивалентности по $\sim_L$.
\item (Далее считаем $Q_i$ за состояния). Установим биекцию между классами эквивалентности и состояниями минимального ДКА, которая сохраняет функцию переходов, т.е. построим изоморфизм $\varphi\colon \{Q_i\}\leftrightarrow \{C_i\}$. На классах эквивалентности функция переходов определяется так: $x_i\in C_i\Rightarrow \delta(C_i,\sigma)=C(x_i\sigma)$ (эта же функция является функцией переходов ДКА из доказательства теоремы 1 третьего задания). Выполним обход графа минимального ДКА и найдем слова $x_i$, по которым можно попасть в $Q_i\colon \delta(Q_0,x_i)=Q_i$. Определим $\varphi(Q_i)=C(x_i)$. Поскольку состояния $Q_i$ попарно неэквивалентны (иначе бы они были склеены), слова $x_i$ попарно не эквивалентны. Значит, $C(x_i)$ попарно различны, и $\varphi$ инъективно. Но поскольку $|\{Q_i\}|=|\{C_i\}|$, оно биективно. Обозначим $C_i=C(x_i)=\varphi(Q_i)$. Докажем сохранение функции переходов:\newline
Пусть $\delta(Q_i,\sigma)=Q_j$. Тогда $\delta(Q_0,x_j)=\delta(Q_0,x_i\sigma)=Q_j$. Поэтому $\forall w\in \Sigma^*\hookrightarrow L\ni x_jw\Leftrightarrow \delta(Q_0,x_jw)\equiv\delta(Q_j,w)\equiv\delta(Q_i,\sigma w)\equiv\delta(Q_0,x_i\sigma w)\in F\Leftrightarrow x_i\sigma w\in L$. Значит, $x_j\sim_L x_i\sigma\Rightarrow C_j=C(x_j)=C(x_i\sigma)=\delta(C_i,\sigma)\,\blacksquare$.\newline
Обратно: $\delta(C_i,\sigma)=C_j\Rightarrow x_i\sigma\sim_L x_j\Rightarrow$ состояния $\delta(Q_0,x_i\sigma)$ и $\delta(Q_0,x_j)$ эквивалентны, а значит, что они совпадают (доказано ранее). Но $Q_j=\delta(Q_0,x_j)=\delta(Q_0,x_i\sigma)=\delta(\delta(Q_0,x_i),\sigma)=\delta(Q_i,\sigma)\,\blacksquare$
\item [4.1.] Таким образом доказано, что любой минимальный ДКА изоморфен в смысле сохранения функции переходов классам эквивалентности. Значит, любые два минимальные ДКА $\A,\B$ для данного языка изоморфны между собой (можно построить изоморфизм $\varphi_{\A,\B}\colon Q^\A\leftrightarrow Q^\B$ как композицию изоморфизмов $Q^A\leftrightarrow \{C_i\}$, $\{C_i\}\leftrightarrow Q^\B$).
% Докажем, что $C_j=\varphi(Q_j)\Leftrightarrow C_j=C(x_j)$. $C_j$
\end{enumerate}
\section*{Задача 1}
%{\em Не очень формально:} Состояниями ДКА будут классы эквивалентности, а переходы будут определны также, как в доказательстве теоремы 1 из третьего задания.\newline Будем искать представителей классов и запоминать их. Для всех найденных классов будем добавлять состояния. Сначала $F\ni C_1=C(\varepsilon)$. Определим $C_1$ как начальное. Рассмотрим $\sigma\in\Sigma$. Если $f(\sigma,\varepsilon)=1$, значит, $\sigma$ лежит в том же классе, что и $\varepsilon$. Определим $\delta(C_1,\sigma)=C_1$. Это соответствует определению в теореме: $\varepsilon\in C_1$, $\varepsilon\sigma\in C_1$. Если же $f(\sigma,\varepsilon)=0$, то они лежат в разных классах. Значит, найден представитель нового класса.
%Запомним его, обозначим $C_2=C(\sigma)$. Добавим состояние $C_2$. Определим $\delta(C_1,\sigma)=C_2$. Повторим для остальных $\sigma\in\Sigma$ (более подробно далее). Далее повторим рассуждение для всех добавленных состояний:\newline
%Заметим, что вместе с состоянием (т.е. классом) известен и представитель $a_k$ его класса $C_k$ (предположение индукции). Рассмотрим $\sigma\in\Sigma$. Если для всех найденных представителей $a_l\in C_l\hookrightarrow f(a_l,a_k\sigma)=0$, то запомним $a_k \sigma$, добавим новое состояние $C(a_k\sigma)$. В любом случае, определим переход $\delta(C(a_k),\sigma)=C(a_k\sigma)$. Свойство $x_i\ni C_i\Rightarrow \delta(C_i,\sigma)=C(x_i\sigma)$ выполнено по построению.\newline
%Всего переходов конечное число (так как состояний конечное число), и на каждом шаге определяются переходы из состояния. Поэтому эта часть алгоритма завершится за конечное время.\newline
%Имеем построенный автомат со свойством: $\delta(q_0,w)=C(w)$. Выполним обход графа автомата, найдем пути до всех состояний, попутно <<собирая>> слова $w$, по которым туда можно попасть. Используя $g(w)$, пометим эти состояния принимающими, если $g(w)=1$. Тогда $\delta(q_0,w)\in F\Leftrightarrow g(w)=1\Leftrightarrow w\in L$.
%\\[5pt]
%Сначала найден $\varepsilon\in C_1$. Если $\varepsilon\sigma\equiv\sigma\notin C(\varepsilon)\Leftrightarrow f(\sigma,\varepsilon)=0$, найден представитель нового класса. Данную процедуру повторяем для всех найденных классов $\sim n^2$ операций, для них же на каждом шаге определяем $\delta(C_i,\sigma)=C_j$, где $x_i\in C_i$~--- найден, $j\colon x_i\sigma\in C_j$. Так будут найдены все классы, потому что на каждом шаге определяются переходы для какого-то состояния ДКА. Состояний конечное число, а когда автомат будет полным, алгоритм можно считать законченным. Корректность следует из построения: $\delta(C_i,\sigma)=C_j\Leftrightarrow x_i\sigma\in C_j$~--- см. доказательство теоремы Майхилла-Нероуда.\newline
%{\em Более формально:} $L\subset\Sigma^*\in\REG,\Sigma^*/\sim_L=\{C_i\}\equiv\{C_1,...,C_n\}$ ($n$ неизвестно, $C_i$ попарно различны). $f\colon \Sigma^*\times\Sigma^*\longrightarrow\{0,1\}$~--- задана, $f(x,y)=1\Leftrightarrow x\sim_Ly$.
%Построим ДКА $\A\colon L(\A)=L$.\newline
%$Q\overset{\mbox{\tiny def}}{=}\{C_i\}, q_0\overset{\mbox{\tiny def}}{=}C(\varepsilon)$. Докажем, что на $n$-м шаге нижеописанного алгоритма выполняется\newline
%$P(n)=[\forall i\in\overline{1,n}\hookrightarrow \mbox{найдены }x_i\in C_i, \forall\sigma\in\Sigma\hookrightarrow\mbox{определены }\delta(C_i,\sigma)=C_j\Leftrightarrow C_i\sigma\in C_j]$.
%\begin{enumerate}
%\item ($n=1$). $\Sigma^*\ni\varepsilon$ принадлежит какому-то классу. Без ограничения общности $\varepsilon\in C_1$. Рассмотрим все $\sigma_k\in\Sigma$. Если $f(\varepsilon,\sigma_k)=1$, то $x$
%ДОДЕЛАТЬ!
\end{enumerate}
\section*{Задача 2}
\section*{Задача 3}
Пусть $x,y$~--- РВ. Ответим на вопрос $L(x)\overset{?}{=}L(y)$.
\begin{enumerate}
\item Построим по $x,y$ НКА $A,B$.
\item Построим по $A,B$ ДКА $A',B'$
\item Построим по $A',B'$ минимальные ДКА $\A'',\B''$. 
\item [4.1] В случае, если $L(\A'')=L(\B'')$, они будут изоморфны (в смысле сохранения функции перехода, доказано в упражнении), что можно проверить одновременным обходом их графов.
\item [4.2] Иначе тот же обход графов покажет, что автоматы различны.
\end{enumerate}
Данный алгоритм не является эффективным, так как количество состояний построенного в (2) ДКА может экспоненциально зависеть от количества состояний НКА, и каждое состояние нужно как минимум создать за $O(1)$, а количество состояний НКА не меньше, чем длина РВ.
%Пусть $x,y$~--- регулярные выражения. Построим НКА $\A,\B$ по РВ $x,y$.
%Докажем, что это можно сделать за $O(|x|^2),O(|y|^2)$: алгоритм сначала ищет самую старшую операцию за $O(|x|)$, затем вызывается рекурсивно для операндов. Каждый из $|x|$ симвов будет рассмотрен не большее количество раз, чем глубина рекурсии, которая не больше $|x|$. При разборе некоторой операции выполняется $O(t)$ действий, где $t$~--- длина подвыражения с этой операцией. Но $t<|x|$.\newline
%Построим ДКА $\A',\B'$ по НКА $\A,\B$. В предыдущем задании было показано, что количество состояний ДКА может экспоненциально зависеть от количества состояний НКА. Но последнее является $O(|x|)$, поэтому уже на этом этапе алгоритм не является эффективным.\newline
%Построим по $\A',\B'$ минимальные ДКА $\A'',\B''$. Если $L(\A)=L(\B)$, то в них будет одинаковое количество состояний (оно равно количеству классов эквивалентности, а это свойство языка, а не автомата). Также множества ${Q^{\A}}''$ и ${Q^{\B}}''$ будут изоморфны (в смысле функций перехода), так как переходы также определяются через классы эквивалентности {\em здесь дырка!}. Изоморфизм можно проверить обходом графов автоматов (например, поиск в ширину/глубину).\newline
%Если же $L(\A)\neq L(\B)$, то алгоритм обхода графа покажет это.
\section*{Задача 4}
\begin{enumerate}
\item $\Sigma=\{0,1\}$. Докажем, что $L(\A)=L$, $L_1\equiv L=\{w\,\big|\,|w|_1=2t,t\in{\mathbb Z}\}$, ДКА $\A:$
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
	  \node[state, initial, accepting]  (q_0)   {$q_0$};
  	  \node[state] (q_1) [right = of q_0] {$q_1$};
  	  \path[->] 
			(q_0)	edge[bend right=40]		node	{$1$}	(q_1)
			(q_1)	edge[bend right=40]		node	{$1$}	(q_0)
			(q_0)	edge[loop below]		node	{$0$}	(q_0)
			(q_1)	edge[loop below]		node	{$0$}	(q_1);
\end{tikzpicture}
\end{center}
Докажем утверждение $P(n)=\big[\forall w\in\Sigma^*\colon |w|=n\hookrightarrow \big(q_0\overset{w}{\longrightarrow}q_i\Rightarrow i=|w|_1\mod 2\big)\big]$.
\begin{enumerate}
\item Докажем $P(0)$. Поскольку $|w|=0\Rightarrow w=\varepsilon$, $P(0)=\big[q_0\overset{\varepsilon}{\longrightarrow}q_i\Rightarrow i=|\varepsilon|_1\mod 2\big]$. Поскольку $\delta(q_0,\varepsilon)=q_{\underline{0}}$, и $\underline{0}=|\varepsilon|_1$, получаем $P(0)\,\blacksquare$
\item Пусть доказано $P(n)$, докажем $P(n+1)$. $P(n)=\big[\forall w\in\Sigma^*\colon |w|=n\hookrightarrow \big(q_0\overset{w}{\longrightarrow}q_i\Rightarrow i=|w|_1\mod 2\big)\big]$. Фиксируем $w\in\Sigma^*,|w|=n+1,w=w_0\sigma,|w_0|=n,|\sigma|=1$. $\A$~--- полный $\Rightarrow(q_0,w)\equiv(q_0,w_0\sigma)\vdash^*(q_i,\sigma)\vdash(q_j,\varepsilon)$. $|w_0|=n\overset{P(n)}{\Rightarrow}i=|w_0|_1\mod 2$. $i\in\{0,1\}\,,\sigma\in\{0,1\}\Rightarrow$ рассмотрим четыре случая:
\begin{enumerate}[a.]
\item ($i=0,\sigma=0$). $(q_0,w_00)\vdash^*(q_0,0)\vdash(q_0,\varepsilon)\Rightarrow q_0\overset{w}{\longrightarrow}q_0\Rightarrow j=0$. $|w|_1\mod 2=|w_0|_1\mod 2+|0|_1\mod 2=0+0=0\Rightarrow 0=j=|w|_1\mod 2=0$.
\item ($i=0,\sigma=1$). $(q_0,w_01)\vdash^*(q_0,1)\vdash(q_1,\varepsilon)\Rightarrow q_0\overset{w}{\longrightarrow}q_1\Rightarrow j=1$. $|w|_1\mod 2=|w_0|_1\mod 2+|1|_1\mod 2=0+1=1\Rightarrow 1=j=|w|_1\mod 2=1$.
\item ($i=1,\sigma=0$). $(q_0,w_00)\vdash^*(q_1,0)\vdash(q_1,\varepsilon)\Rightarrow q_0\overset{w}{\longrightarrow}q_1\Rightarrow j=1$. $|w|_1\mod 2=|w_0|_1\mod 2+|0|_1\mod 2=1+0=1\Rightarrow 1=j=|w|_1\mod 2=1$.
\item ($i=1,\sigma=1$). $(q_0,w_01)\vdash^*(q_1,1)\vdash(q_0,\varepsilon)\Rightarrow q_0\overset{w}{\longrightarrow}q_0\Rightarrow j=0$. $|w|_1\mod 2=|w_0|_1\mod 2+|1|_1\mod 2=(1+1)\mod 2=0\Rightarrow 0=j=|w|_1\mod 2=0$.
\end{enumerate}
\end{enumerate}
Таким образом, $\forall n\in{\mathbb N}\cup\{0\}\hookrightarrow P(n)\Rightarrow \forall n\in{\mathbb N}\cup\{0\}\hookrightarrow \big[\forall w\in\Sigma^*\colon |w|=n\hookrightarrow \big(q_0\overset{w}{\longrightarrow}q_i\Rightarrow i=|w|_1\mod 2\big)\big]\Rightarrow\newline\forall w\in\Sigma^*\hookrightarrow q_0\overset{w}{\longrightarrow}q_{|w|_1\mod 2}$.
Пусть $w\in L\Leftrightarrow |w|_1\mod 2=0\Leftrightarrow q_0\overset{w}{\longrightarrow}q_0\Leftrightarrow w\in L(\A)\,\blacksquare$
\item $\Sigma=\{0,1\}$. $L_2=\{w\,\big|\,|w|_0=2t+1,t\in{\mathbb Z}\}$. Воспользуемся результатом (4.1) и построим ДКА $\B$:\\
\begin{minipage}{0.8\textwidth}
\begin{tabular}{l l}
\begin{minipage}{0.8\textwidth}
Поменяем в автомате из (4.1) нули и единицы местами. Получим $\A'$. Очевидно, $\A'$ будет распознавать все слова, в которых четное количество нулей. $
A'$~--- полный, и все состояния достижимы из $q_0$.
\end{minipage}&
\begin{minipage}{0.4\textwidth}
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
	  \node[state, initial, accepting]  (q_0)   {$q_0$};
  	  \node[state] (q_1) [right = of q_0] {$q_1$};
  	  \path[->] 
			(q_0)	edge[bend right=40]		node	{$0$}	(q_1)
			(q_1)	edge[bend right=40]		node	{$0$}	(q_0)
			(q_0)	edge[loop below]		node	{$1$}	(q_0)
			(q_1)	edge[loop below]		node	{$1$}	(q_1);
\end{tikzpicture}
\end{center}
\end{minipage}\\
\begin{minipage}{0.8\textwidth}
Поэтому, переопределив $F''=Q''\setminus F$, получим $\A''\equiv\B$, который распознает все слова, в которых нечетное количество нулей.
\end{minipage}&
\begin{minipage}{0.4\textwidth}
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
	  \node[state, initial]  (q_0)   {$q_0$};
  	  \node[state, accepting] (q_1) [right = of q_0] {$q_1$};
  	  \path[->] 
			(q_0)	edge[bend right=40]		node	{$0$}	(q_1)
			(q_1)	edge[bend right=40]		node	{$0$}	(q_0)
			(q_0)	edge[loop below]		node	{$1$}	(q_0)
			(q_1)	edge[loop below]		node	{$1$}	(q_1);
\end{tikzpicture}
\end{center}
\end{minipage}\\
\end{tabular}
\end{minipage}
\item Поскольку $L_3=\{\mbox{слова из 0 и 1, в которых четное число единиц и нечетное число нулей}\}=\newline=\{\mbox{слова из 0 и 1, в которых четное число единиц}\}\cap\{\mbox{слова из 0 и 1, в которых нечетное число нулей}\}\equiv L_1\cap L_2$, построим $\C\colon L(\C)=L_3$ по алгоритму, который докажем далее, в (4.4):
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
	  \node[state, initial]  (q_00)   {$q^0_0$};
  	  \node[state, accepting] (q_01) [above right = of q_00] {$q^0_1$};
   	  \node[state] (q_10) [below right = of q_00] {$q^1_0$};
   	  \node[state] (q_11) [above right = of q_10] {$q^1_1$};
   	   \path[->] 
   	 		(q_00)	edge[bend left]		node	{$0$}	(q_01)
   	 				edge[bend left]  node[swap] {$1$}	(q_10)
   	 		(q_01)  edge[bend left]		node[swap]	{$0$}	(q_00)
   	 		   	 	edge[bend left]  node {$1$}	(q_11)
   	 		(q_10)  edge[bend left]		node[swap]	{$0$}	(q_11)
   	 		   	 	edge[bend left]  node {$1$}	(q_00)
   	 		(q_11)  edge[bend left]		node	{$0$}	(q_10)
   	 		   	 	edge[bend left]  node[swap] {$1$}	(q_01);
\end{tikzpicture}
\end{center}
\item Дано: $\Sigma$~--- алфавит, $\A=(Q^\A,\Sigma,q^\A_0,\delta^\A,F^\A),\,\B=(Q^\B,\Sigma,q^\B_0,\delta^\B,F^\B)$~--- полные ДКА, в которых все состояния достижимы из начальных. $\Sigma^*\supset L^\A=L(\A),\Sigma^*\supset L^\B=L(\B)$. Задача: построить ДКА $\C=(Q^\C,\Sigma,q^\C_0,\delta^\C,F^\C)\colon L(\C)=L^\A\cap L^\B$.
\\[5pt]
Определим $Q^\C=Q^\A\times Q^\B$~--- множество всех пар состояних исходных автоматов.\newline
Для краткости будем обозначать $Q^\C\ni (q^\A_i,q^\B_j)\overset{\mbox{\tiny def}}{\equiv}q^i_j$.\newline
Определим $q^\C_0\overset{\mbox{\tiny def}}{=}q^0_0$, $F^\C=\{q^i_j\big|q^\A_i\in F^\A\wedge q^\B_j\in F^\B\}$\newline
Определим $\delta^\C(q^i_j,\sigma)=\big(\delta^\A(q^\A_i,\sigma),\delta^\B(q^\B_j,\sigma)\big)$\newline
Докажем утверждение\newline
$P(n)=\big[\forall w\in\Sigma^*\colon |w|=n\hookrightarrow q^0_0\overset{w}{\longrightarrow}\big(\delta^\A(q^\A_0,w),\,\delta^\B(q^\B_0,w)\big)\big]$
\begin{enumerate}[a.]
\item ($n=0$) $\Sigma^*\ni w,|w|=0\Rightarrow w=\varepsilon$. Тогда $\delta^\C(q^0_0,\varepsilon)\overset{\mbox{\tiny по опр.}}{=}\big(\delta^\A(q^\A_0,\varepsilon),\delta^\B(q^\B_0,\varepsilon)\big)$, как и требовалось.
\item ($n=1$) $\Sigma^*\ni w,|w|=1\Rightarrow w=\sigma\in\Sigma$. Тогда $\delta^\C(q^0_0,w)=\delta^\C(q^0_0,\sigma)\overset{\mbox{\tiny по опр.}}{=}\big(\delta^\A(q^\A_0,\sigma),\delta^\B(q^\B_0,\sigma)\big)$, как и требовалось.
\item ($n+1$). Пусть $P(n)$. Докажем $P(n+1)$. Фиксируем $\Sigma^*\ni w\colon |w|=n+1$. Тогда $w\equiv w_0\sigma,\,|w_0|=n\,\sigma\in\Sigma$. $\delta^\C(q^0_0,w)=\delta^\C(q^0_0,w_0\sigma)\equiv\delta^\C(\delta^\C(q^0_0,w_0),\sigma)\overset{P(n)}{=}\delta^\C(\big(\delta^\A(q^\A_0,w_0),\,\delta^\B(q^\B_0,w_0)\big),\sigma)\overset{\mbox{\tiny по опр.}}{=}\big(\delta^\A(\delta^\A(q^\A_0,w_0),\sigma),\delta^\B(\delta^\B(q^\B_0,w_0),\sigma)\big)\underset{\delta^\A, \delta^\B}{\overset{\mbox{\tiny св-во }}{=}}\big(\delta^\A(q^\A_0,w),\delta^\B(q^\B_0,w)\big)\Rightarrow P(n+1)$.
\end{enumerate}
Получаем $w\in L^\A\cap L^\B\Leftrightarrow w\in L(\A)\cap L(\B)\Leftrightarrow\begin{cases}
w\in L(\A)\\
w\in L(\B)
\end{cases}\Leftrightarrow \begin{cases}
\delta^\A(q^\A_0,w)\in F^\A\\
\delta^\B(q^\B_0,w)\in F^\B\\
\end{cases}\Leftrightarrow \big(\delta^\A(q^\A_0,w),\delta^\B(q^\B_0,w)\big)\in F^\C\overset{P(|w|)}{\Leftrightarrow} \delta^\C(q^0_0,w)\in F^\C\Leftrightarrow w\in L(\C)\,\blacksquare$
\end{enumerate}
\section*{Задача 5}
\begin{tabular}{l l}
Исходный автомат $\A$: & 
\begin{minipage}{0.4\textwidth}\begin{center}
% копипаста из задания
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
  %\draw[help lines] (0,0) grid (3,2);
  \node[state ,initial] (q_0) 					 {$q_0$};
  \node[state, accepting]		    (q_1) [ right = of q_0 ] {$q_1$};
  \node[state]          (q_2) [ right = of q_1] {$q_2$};
  \node[state, accepting]           (q_3) [ right = of q_2] {$q_3$};

  \path[->] 
		(q_0)	edge		node	{$a$}	(q_1)
				edge [bend left] node {$b$}	(q_3)
		(q_1)
				edge		node	{$b$}	(q_2)
		(q_2)
				edge		node	{$b$}	(q_3)
				edge [bend left] node {$a$}	(q_1);
\end{tikzpicture}
\end{center}\end{minipage}\\
\begin{minipage}{0.4\textwidth}
Пополним автомат $\A$ до $\A'$ и удалим недостижимые из $q_0$ состояния: добавим $q_4\in Q',\,q_4\notin F'$, в него направим недостающие переходы:
\end{minipage} &
\begin{minipage}{0.4\textwidth}
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
  %\draw[help lines] (0,0) grid (3,2);
  \node[state ,initial] (q_0) 					 {$q_0$};
  \node[state, accepting]		    (q_1) [ right = of q_0 ] {$q_1$};
  \node[state]          (q_2) [ right = of q_1] {$q_2$};
  \node[state, accepting]           (q_3) [ right = of q_2] {$q_3$};
  \node[state]           (q_4) [ below = of q_2] {$q_4$};

  \path[->] 
		(q_0)	edge		node	{$a$}	(q_1)
				edge [bend left] node {$b$}	(q_3)
		(q_1)
				edge		node	{$b$}	(q_2)
				edge [bend right]		node	{$a$}	(q_4)
		(q_2)
				edge		node	{$b$}	(q_3)
				edge [bend left] node {$a$}	(q_1)
		(q_3)
				edge [bend left]		node	{$b$}	(q_4)
				edge [bend right]		node	{$a$}	(q_4)
		(q_4)
				edge [loop below]		node	{$a,b$}	(q_4);
\end{tikzpicture}
\end{center}
\end{minipage}\\
\end{tabular}\newline
$L(\A')=L(\A)$, так как $x\in L(\A)\Rightarrow x\in L(\A')$, потому что $Q\subset Q',\,F=F',\delta\subset\delta'$. $x\notin L(\A)\Rightarrow$ либо $q_0\overset{x}{\longrightarrow}q\notin F$, но тогда $q_0\overset{x}{\longrightarrow}q\notin F'\Rightarrow x\notin L(\A')$, либо $\delta(q_0,x)=\varnothing$, тогда $\delta'(q_0,x)=q_4$, потому что был выполнен переход в $q_4$, которого не было в $\A$ (по построению, добавлены переходы только в $q_4$), и при обработке последующих символов $\A'$ остается в $q_4$.
\\[5pt]
\begin{tabular}{l l}
\begin{minipage}{0.4\textwidth}
Построим $A''\colon L(\A'')=\overline{L(\A')}\equiv\overline{L(\A)}$ по полному автомату $\A'$, определив $F''\overset{\mbox{\tiny def}}{=}Q'\setminus F'$:
\end{minipage} &
\begin{minipage}{0.4\textwidth}
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
  %\draw[help lines] (0,0) grid (3,2);
  \node[state, initial, accepting] (q_0) 					 {$q_0$};
  \node[state]		    (q_1) [ right = of q_0 ] {$q_1$};
  \node[state, accepting]          (q_2) [ right = of q_1] {$q_2$};
  \node[state]           (q_3) [ right = of q_2] {$q_3$};
  \node[state, accepting]           (q_4) [ below = of q_2] {$q_4$};

  \path[->] 
		(q_0)	edge		node	{$a$}	(q_1)
				edge [bend left] node {$b$}	(q_3)
		(q_1)
				edge		node	{$b$}	(q_2)
				edge [bend right]		node	{$a$}	(q_4)
		(q_2)
				edge		node	{$b$}	(q_3)
				edge [bend left] node {$a$}	(q_1)
		(q_3)
				edge [bend left]		node	{$b$}	(q_4)
				edge [bend right]		node	{$a$}	(q_4)
		(q_4)
				edge [loop below]		node	{$a,b$}	(q_4);
\end{tikzpicture}
\end{center}
\end{minipage}\\
\end{tabular}
\newline
Далее построим по $\A''$ минимальный $\A'''$ по алгоритму:
\newline
\begin{tabular}{c c}
\begin{minipage}{0.4\textwidth}
\begin{enumerate}[1.]
\item \begin{tikzpicture}[baseline=-0.5ex,node distance=10mm,on grid,auto]
\node (d_b) {$\big\{$};
\node (q_0) [node distance=3mm, right of=d_b] {$0$};
\node (q_2) [right of=q_0] {$2$};
\node (q_4) [right of=q_2] {$4$};
\node (d_41) [node distance=5mm, right of=q_4] {$\big|$};
\node (q_1) [right of=q_4] {$1$};
\node (q_3) [right of=q_1] {$3$};
\node (d_f) [node distance=3mm,right of=q_3] {$\big\}$};
\draw[->, bend left] (q_0) to node {$a$} (q_1);
\draw[->, bend left] (q_2) to node {$a$} (q_1);
\draw[->, loop below] (q_4) to node {$a$} (q_4);
\draw[->, bend left] (q_1) to node {$a$} (q_4);
\draw[->, bend right=50] (q_3) to node {$a$} (q_4);
\end{tikzpicture}
\item \begin{tikzpicture}[baseline=-0.5ex,node distance=10mm,on grid,auto]
\node (d_b) {$\big\{$};
\node (q_0) [node distance=3mm, right of=d_b] {$0$};
\node (q_2) [right of=q_0] {$2$};
\node (d_02) [node distance=5mm, right of=q_2] {$\big|$};
\node (q_4) [right of=q_2] {$4$};
\node (d_41) [node distance=5mm, right of=q_4] {$\big|$};
\node (q_1) [right of=q_4] {$1$};
\node (d_13) [node distance=5mm, right of=q_1] {$\big|$};
\node (q_3) [right of=q_1] {$3$};
\node (d_f) [node distance=3mm,right of=q_3] {$\big\}$};
\draw[->, bend right] (q_0) to node {$b$} (q_3);
\draw[->, bend right] (q_2) to node [swap] {$b$} (q_3);
\draw[->, loop below] (q_4) to node {$b$} (q_4);
\draw[->, bend right] (q_1) to node [swap] {$b$} (q_2);
\draw[->, bend right=50] (q_3) to node [swap] {$b$} (q_4);
\end{tikzpicture}~--- OK
\item \begin{tikzpicture}[baseline=-0.5ex,node distance=10mm,on grid,auto]
\node (d_b) {$\big\{$};
\node (q_0) [node distance=3mm, right of=d_b] {$0$};
\node (q_2) [right of=q_0] {$2$};
\node (d_02) [node distance=5mm, right of=q_2] {$\big|$};
\node (q_4) [right of=q_2] {$4$};
\node (d_41) [node distance=5mm, right of=q_4] {$\big|$};
\node (q_1) [right of=q_4] {$1$};
\node (d_13) [node distance=5mm, right of=q_1] {$\big|$};
\node (q_3) [right of=q_1] {$3$};
\node (d_f) [node distance=3mm,right of=q_3] {$\big\}$};
\draw[->, bend left] (q_0) to node {$a$} (q_1);
\draw[->, bend left] (q_2) to node {$a$} (q_1);
\draw[->, loop below] (q_4) to node {$a$} (q_4);
\draw[->, bend left] (q_1) to node {$a$} (q_4);
\draw[->, bend right=50] (q_3) to node {$a$} (q_4);
\end{tikzpicture}~--- OK
\end{enumerate}
\end{minipage} &
\begin{minipage}{0.3\textwidth}
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
  %\draw[help lines] (0,0) grid (3,2);
  \node[state, initial, accepting] (q_0) 					 {$q_0$};
  \node[state]		    (q_1) [ right = of q_0 ] {$q_1$};
  \node[state, accepting] (q_4) [ right = of q_1] {$q_4$};
  \node[state]           (q_3) [ right = of q_4] {$q_3$};

  \path[->] 
		(q_0)	edge [bend right]		node	{$a$}	(q_1)
				edge [bend left] node {$b$}	(q_3)
		(q_1)
				edge [bend right]		node	{$b$}	(q_0)
				edge 		node	{$a$}	(q_4)
		(q_3)
				edge [bend left]		node	{$b$}	(q_4)
				edge [bend right]		node	{$a$}	(q_4)
		(q_4)
				edge [loop below]		node	{$a,b$}	(q_4);
\end{tikzpicture}
\end{center}
\end{minipage}\\
\end{tabular}
\section*{Задача 6}
\end{document}
